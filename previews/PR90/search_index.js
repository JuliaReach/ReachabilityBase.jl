var documenterSearchIndex = {"docs":
[{"location":"lib/Comparison/#Comparison","page":"Comparison","title":"Comparison","text":"","category":"section"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"This section of the manual describes the Comparison module.","category":"page"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"Pages = [\"Comparison.md\"]\nDepth = 3","category":"page"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"CurrentModule = ReachabilityBase.Comparison","category":"page"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"Comparison","category":"page"},{"location":"lib/Comparison/#ReachabilityBase.Comparison","page":"Comparison","title":"ReachabilityBase.Comparison","text":"Comparison\n\nThis module provides convenience functions to compare numerical values up to some user-controlled precision.\n\n\n\n\n\n","category":"module"},{"location":"lib/Comparison/#Tolerance","page":"Comparison","title":"Tolerance","text":"","category":"section"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"Comparison.Tolerance","category":"page"},{"location":"lib/Comparison/#ReachabilityBase.Comparison.Tolerance","page":"Comparison","title":"ReachabilityBase.Comparison.Tolerance","text":"Tolerance{N<:Number}\n\nType that represents the tolerances for a given numeric type.\n\nFields\n\nrtol – relative tolerance\nztol – zero tolerance or absolute tolerance for comparison against zero\natol – absolute tolerance\n\nNotes\n\nThe type Tolerance, parametric in the numeric type N, is used to store default values for numeric comparisons. It is mutable and setting the value of a field affects the getter functions hence it can be used to globally fix the tolerance.\n\nDefault values are defined for the most commonly used numeric types, and for those cases when other numeric types are needed one can extend the default values as explained next.\n\nThe cases Float64 and Rational are special in the sense that they are the most commonly used types in applications. Getting and setting default tolerances is achieved with the functions _rtol and set_rtol (and similarly for the other tolerances); the implementation creates an instance of Tolerance{Float64} (resp. Tolerance{Rational}) and sets some default values. Again since Tolerance is mutable, setting a value is possible e.g. set_rtol(Type{Float64}, ε) for some floating-point ε.\n\nFor all other cases, a dictionary mapping numeric types to instances of Tolerance for that numeric type is used. For floating-point types, a default value has been defined through default_tolerance as follows:\n\ndefault_tolerance(N::Type{<:AbstractFloat}) = Tolerance(Base.rtoldefault(N), N(10) * sqrt(eps(N)), zero(N))\n\nHence to set a single tolerance (either rtol, ztol or atol) for a given floating-point type, use the corresponding set_rtol function, while the values which have not been set will be pulled from default_tolerance. If you would like to define the three default values at once, or are computing with a non floating-point numeric type, you can just extend default_tolerance(N::Type{<:Number}).\n\n\n\n\n\n","category":"type"},{"location":"lib/Comparison/#Approximate-comparison","page":"Comparison","title":"Approximate comparison","text":"","category":"section"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"isapproxzero\n_isapprox\n_leq\n_geq","category":"page"},{"location":"lib/Comparison/#ReachabilityBase.Comparison.isapproxzero","page":"Comparison","title":"ReachabilityBase.Comparison.isapproxzero","text":"isapproxzero(x::N; ztol::Real=_ztol(N)) where {N<:Real}\n\nDetermine if x is approximately zero.\n\nInput\n\nx    – number\nztol – (optional, default: _ztol(N)) tolerance against zero\n\nOutput\n\nA boolean that is true iff x ≈ 0.\n\nAlgorithm\n\nIt is considered that x ≈ 0 whenever x (in absolute value) is smaller than the tolerance for zero, ztol.\n\n\n\n\n\n","category":"function"},{"location":"lib/Comparison/#ReachabilityBase.Comparison._isapprox","page":"Comparison","title":"ReachabilityBase.Comparison._isapprox","text":"_isapprox(x::N, y::N;\n          rtol::Real=_rtol(N),\n          ztol::Real=_ztol(N),\n          atol::Real=_atol(N)) where {N<:Real}\n\nDetermine if x is approximately equal to y.\n\nInput\n\nx    – number\ny    – another number (of the same numeric type as x)\nrtol – (optional, default: _rtol(N)) relative tolerance\nztol – (optional, default: _ztol(N)) absolute tolerance for comparison           against zero\natol – (optional, default: _atol(N)) absolute tolerance\n\nOutput\n\nA boolean that is true iff x ≈ y.\n\nAlgorithm\n\nWe first check if x and y are both approximately zero, using isapproxzero(x, y). If that fails, we check if x ≈ y, using Julia's isapprox(x, y). In the latter check we use atol absolute tolerance and rtol relative tolerance.\n\nComparing to zero with default tolerances is a special case in Julia's isapprox, see the last paragraph in ?isapprox. This function tries to combine isapprox with its default values and a branch for x ≈ y ≈ 0 which includes x == y == 0 but also admits a tolerance ztol.\n\nNote that if x = ztol and y = -ztol, then |x-y| = 2*ztol and still _isapprox returns true.\n\n\n\n\n\n","category":"function"},{"location":"lib/Comparison/#ReachabilityBase.Comparison._leq","page":"Comparison","title":"ReachabilityBase.Comparison._leq","text":"_leq(x::Real, y::Real; [kwargs...])\n\nDetermine if x is smaller than or equal to y.\n\nInput\n\nx    – number\ny    – number\nrtol – (optional; default: _rtol(N)) relative tolerance\nztol – (optional; default: _ztol(N)) absolute tolerance for comparison           against zero\natol – (optional; default: _atol(N)) absolute tolerance\n\nOutput\n\nA boolean that is true iff x <= y.\n\nAlgorithm\n\nThe x <= y comparison is split into x < y or x ≈ y; the latter is implemented by extending Juila's built-in isapprox(x, y) with an absolute tolerance that is used to compare against zero.\n\n\n\n\n\n","category":"function"},{"location":"lib/Comparison/#ReachabilityBase.Comparison._geq","page":"Comparison","title":"ReachabilityBase.Comparison._geq","text":"_geq(x::Real, y::Real; [kwargs...])\n\nDetermine if x is greater than or equal to y.\n\nInput\n\nx    – number\ny    – number\nrtol – (optional; default: _rtol(N)) relative tolerance\nztol – (optional; default: _ztol(N)) absolute tolerance for comparison           against zero\natol – (optional; default: _atol(N)) absolute tolerance\n\nOutput\n\nA boolean that is true iff x >= y.\n\nAlgorithm\n\nThis function falls back to _leq(y, x), with type promotion if needed. See the documentation of _leq for further details.\n\n\n\n\n\n","category":"function"},{"location":"lib/Comparison/#Approximate-operations","page":"Comparison","title":"Approximate operations","text":"","category":"section"},{"location":"lib/Comparison/","page":"Comparison","title":"Comparison","text":"_in","category":"page"},{"location":"lib/Comparison/#ReachabilityBase.Comparison._in","page":"Comparison","title":"ReachabilityBase.Comparison._in","text":"_in(x, itr)\n\nApproximate containment check.\n\nInput\n\nx   – element\nitr – iterable\n\nOutput\n\nA boolean that is true iff y ∈ itr for some y ≈ x.\n\n\n\n\n\n","category":"function"},{"location":"lib/Assertions/#Assertions","page":"Assertions","title":"Assertions","text":"","category":"section"},{"location":"lib/Assertions/","page":"Assertions","title":"Assertions","text":"This section of the manual describes the Assertions module.","category":"page"},{"location":"lib/Assertions/","page":"Assertions","title":"Assertions","text":"Pages = [\"Assertions.md\"]\nDepth = 3","category":"page"},{"location":"lib/Assertions/","page":"Assertions","title":"Assertions","text":"CurrentModule = ReachabilityBase.Assertions","category":"page"},{"location":"lib/Assertions/","page":"Assertions","title":"Assertions","text":"Assertions\nactivate_assertions\ndeactivate_assertions","category":"page"},{"location":"lib/Assertions/#ReachabilityBase.Assertions","page":"Assertions","title":"ReachabilityBase.Assertions","text":"Assertions\n\nThis module provides a quick way to deactivate and reactivate Julia's @assert checks. This can be useful for performance-critical runs.\n\nNotes\n\nThe implementation is based on the idea from here.\n\n\n\n\n\n","category":"module"},{"location":"lib/Assertions/#ReachabilityBase.Assertions.activate_assertions","page":"Assertions","title":"ReachabilityBase.Assertions.activate_assertions","text":"activate_assertions(m::Module)\n\nActivate @assert checks for the given module.\n\nInput\n\nm – module\n\n\n\n\n\n","category":"function"},{"location":"lib/Assertions/#ReachabilityBase.Assertions.deactivate_assertions","page":"Assertions","title":"ReachabilityBase.Assertions.deactivate_assertions","text":"deactivate_assertions(m::Module)\n\nDeactivate @assert checks for the given module.\n\nInput\n\nm – module\n\n\n\n\n\n","category":"function"},{"location":"lib/Timing/#Timing","page":"Timing","title":"Timing","text":"","category":"section"},{"location":"lib/Timing/","page":"Timing","title":"Timing","text":"This section of the manual describes the Timing module.","category":"page"},{"location":"lib/Timing/","page":"Timing","title":"Timing","text":"Pages = [\"Timing.md\"]\nDepth = 3","category":"page"},{"location":"lib/Timing/","page":"Timing","title":"Timing","text":"CurrentModule = ReachabilityBase.Timing","category":"page"},{"location":"lib/Timing/","page":"Timing","title":"Timing","text":"Timing\nprint_timed","category":"page"},{"location":"lib/Timing/#ReachabilityBase.Timing","page":"Timing","title":"ReachabilityBase.Timing","text":"Timing\n\nThis module provides timing-related functionality.\n\n\n\n\n\n","category":"module"},{"location":"lib/Timing/#ReachabilityBase.Timing.print_timed","page":"Timing","title":"ReachabilityBase.Timing.print_timed","text":"print_timed(stats::NamedTuple; [io]::IO=stdout)\n\nPrint the result of a @timed call.\n\nInput\n\nstats – the result of a @timed call\nio    – (optional; default: stdout) where the output is written (ignored            prior to Julia v1.10)\n\n\n\n\n\n","category":"function"},{"location":"lib/Commutative/#Commutative","page":"Commutative","title":"Commutative","text":"","category":"section"},{"location":"lib/Commutative/","page":"Commutative","title":"Commutative","text":"This section of the manual describes the Commutative module.","category":"page"},{"location":"lib/Commutative/","page":"Commutative","title":"Commutative","text":"Pages = [\"Commutative.md\"]\nDepth = 3","category":"page"},{"location":"lib/Commutative/","page":"Commutative","title":"Commutative","text":"CurrentModule = ReachabilityBase.Commutative","category":"page"},{"location":"lib/Commutative/","page":"Commutative","title":"Commutative","text":"Commutative\n@commutative","category":"page"},{"location":"lib/Commutative/#ReachabilityBase.Commutative","page":"Commutative","title":"ReachabilityBase.Commutative","text":"Commutative\n\nThis module provides the convenience macro @commutative to automatically duplicate a method with the first and second arguments swapped.\n\n\n\n\n\n","category":"module"},{"location":"lib/Commutative/#ReachabilityBase.Commutative.@commutative","page":"Commutative","title":"ReachabilityBase.Commutative.@commutative","text":"@commutative(f)\n\nMacro to declare that a given method is commutative, thus generating the original method and a new method where the first and second arguments are swapped.\n\nInput\n\nf – method definition\n\nOutput\n\nA quoted expression containing the method definitions.\n\n\n\n\n\n","category":"macro"},{"location":"lib/CurrentPath/#CurrentPath","page":"CurrentPath","title":"CurrentPath","text":"","category":"section"},{"location":"lib/CurrentPath/","page":"CurrentPath","title":"CurrentPath","text":"This section of the manual describes the CurrentPath module.","category":"page"},{"location":"lib/CurrentPath/","page":"CurrentPath","title":"CurrentPath","text":"Pages = [\"CurrentPath.md\"]\nDepth = 3","category":"page"},{"location":"lib/CurrentPath/","page":"CurrentPath","title":"CurrentPath","text":"CurrentModule = ReachabilityBase.CurrentPath","category":"page"},{"location":"lib/CurrentPath/","page":"CurrentPath","title":"CurrentPath","text":"CurrentPath\n@current_path","category":"page"},{"location":"lib/CurrentPath/#ReachabilityBase.CurrentPath","page":"CurrentPath","title":"ReachabilityBase.CurrentPath","text":"CurrentPath\n\nThis module provides the macro @current_path to conveniently update a path. This is useful for loading files in combination with the Literate package.\n\n\n\n\n\n","category":"module"},{"location":"lib/CurrentPath/#ReachabilityBase.CurrentPath.@current_path","page":"CurrentPath","title":"ReachabilityBase.CurrentPath.@current_path","text":"@current_path([prefix], filename)\n\nReturn the absolute path to file filename relative to the executing script.\n\nInput\n\nprefix   – path prefix (optional; ignored by default)\nfilename – filename\n\nOutput\n\nThe string corresponding to the absolute path of the file.\n\nNotes\n\nThis macro is equivalent to joinpath(@__DIR__, filename). It is useful in scripts to load data files relative to the location of the script without having to change the directory of the Julia session. For instance, suppose that the folder /home/models/my_model contains the script my_model.jl, and suppose that the data file my_data.dat located in the same directory is required to be loaded by my_model.jl. Suppose further that the working directory is /home/julia/ and we ran the script as julia -e \"include(\"../models/my_model/my_model.jl\")\". In the model file /home/models/my_model/my_model.jl we write:\n\nd = open(@current_path(\"my_model\", \"my_data.dat\"))\n# do something with d\n\nIn this example, the macro @current_path(\"my_model\", \"my_data.dat\") evaluates to the string /home/models/my_model/my_data.dat. If the script my_model.jl only had d = open(\"my_data.dat\"), without @current_path, this command would fail, as Julia would have looked for my_data.dat in the working directory, resulting in an error that the file /home/julia/my_data.dat is not found.\n\nThe real convenience enters when including the script my_model in combination with the Literate package. In this case, we need to prepend the folder my_model for prefix; hence we redefine the definition to:\n\nmacro current_path(prefix::String, filename::String)\n    return joinpath(\"home\", \"models\", prefix, filename)\nend\n\n\n\n\n\n","category":"macro"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If you like this package, consider contributing!","category":"page"},{"location":"about/","page":"About","title":"About","text":"Creating an issue in the ReachabilityBase GitHub issue tracker to report a bug, open a discussion about existing functionality, or suggesting new functionality is appreciated.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you have written code and would like it to be peer reviewed and added to the library, you can fork the repository and send a pull request (see below). Typical contributions include fixing a bug, adding a new feature or improving the documentation (either in source code or the online manual).","category":"page"},{"location":"about/","page":"About","title":"About","text":"Below we detail some general comments about contributing to this package. The JuliaReach Developer's Documentation describes coding guidelines; take a look when in doubt about the coding style that is expected for the code that is finally merged into the library.","category":"page"},{"location":"about/#Branches-and-pull-requests-(PR)","page":"About","title":"Branches and pull requests (PR)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"We use a standard pull request policy: You work in a private branch and eventually add a pull request, which is then reviewed by other programmers and merged into the master branch.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Each pull request should be pushed in a new branch with the name of the author followed by a descriptive name, e.g., mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g., mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This project is synchronized with GitHub Actions such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to make all unit tests pass.","category":"page"},{"location":"about/","page":"About","title":"About","text":"To run the unit tests locally, you can do:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> using Pkg\n\njulia> Pkg.test(\"ReachabilityBase\")","category":"page"},{"location":"about/","page":"About","title":"About","text":"We also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"page"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"New functions and types should be documented according to the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/","page":"About","title":"About","text":"The documentation you are currently reading is written in Markdown, and it relies on the package Documenter.jl to produce the HTML layout. The sources for creating this documentation are found in docs/src. You can easily include the documentation that you wrote for your functions or types there (see the source code or Documenter's guide for examples).","category":"page"},{"location":"about/","page":"About","title":"About","text":"To generate the documentation locally, run make.jl, e.g., by executing the following command in the terminal:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/#Credits","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Here we list the names of the maintainers of the ReachabilityBase.jl library (in alphabetic order).","category":"page"},{"location":"about/#Core-developers","page":"About","title":"Core developers","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Marcelo Forets, Universidad de la República\nChristian Schilling, Aalborg University","category":"page"},{"location":"lib/Distribution/#Distribution","page":"Distribution","title":"Distribution","text":"","category":"section"},{"location":"lib/Distribution/","page":"Distribution","title":"Distribution","text":"This section of the manual describes the Distribution module.","category":"page"},{"location":"lib/Distribution/","page":"Distribution","title":"Distribution","text":"Pages = [\"Distribution.md\"]\nDepth = 3","category":"page"},{"location":"lib/Distribution/","page":"Distribution","title":"Distribution","text":"CurrentModule = ReachabilityBase.Distribution","category":"page"},{"location":"lib/Distribution/","page":"Distribution","title":"Distribution","text":"Distribution\nreseed!\nDefaultUniform","category":"page"},{"location":"lib/Distribution/#ReachabilityBase.Distribution","page":"Distribution","title":"ReachabilityBase.Distribution","text":"Distribution\n\nThis module provides some light-weight random number functionality.\n\n\n\n\n\n","category":"module"},{"location":"lib/Distribution/#ReachabilityBase.Distribution.reseed!","page":"Distribution","title":"ReachabilityBase.Distribution.reseed!","text":"reseed!(rng::AbstractRNG, seed::Union{Int, Nothing})\n\nReset the RNG seed if the seed argument is a number.\n\nInput\n\nrng  – random number generator\nseed – seed for reseeding, or nothing\n\nOutput\n\nThe input RNG if the seed is nothing, and a reseeded RNG otherwise.\n\nNotes\n\nThis is a convenience function to be called unconditionally. The motivation is to simplify library code, with seed as user input.\n\n\n\n\n\n","category":"function"},{"location":"lib/Distribution/#ReachabilityBase.Distribution.DefaultUniform","page":"Distribution","title":"ReachabilityBase.Distribution.DefaultUniform","text":"DefaultUniform{N}\n\nRepresents a uniform distribution over an interval a b.\n\nFields\n\na – lower bound\nb – upper bound\n\n\n\n\n\n","category":"type"},{"location":"lib/Arrays/#Arrays","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"lib/Arrays/","page":"Arrays","title":"Arrays","text":"This section of the manual describes the Arrays module.","category":"page"},{"location":"lib/Arrays/","page":"Arrays","title":"Arrays","text":"Pages = [\"Arrays.md\"]\nDepth = 3","category":"page"},{"location":"lib/Arrays/","page":"Arrays","title":"Arrays","text":"CurrentModule = ReachabilityBase.Arrays","category":"page"},{"location":"lib/Arrays/","page":"Arrays","title":"Arrays","text":"Arrays\nargmaxabs\ncross_product(::AbstractMatrix{N}) where {N<:Real}\ndistance(::AbstractVector{N}, ::AbstractVector{N}; ::Real=N(2)) where {N}\ndot_zero\nextend\nextend_with_zeros\nhasfullrowrank\ninner\nis_cyclic_permutation\nis_right_turn\nisabove\nisinvertible\nismultiple\nispermutation\nissquare\niswellconditioned\nmatrix_type\nnonzero_columns\nnonzero_indices\nprojection_matrix\nrand_pos_neg_zerosum_vector\nrationalize\nrectify\nremove_duplicates_sorted!\nremove_zero_columns\nright_turn\nsame_sign\nsamedir\nSingleEntryVector\nsubstitute\nsubstitute!\nto_matrix\nto_negative_vector\nuniform_partition\nvector_type","category":"page"},{"location":"lib/Arrays/#ReachabilityBase.Arrays","page":"Arrays","title":"ReachabilityBase.Arrays","text":"Arrays\n\nThis module provides machinery for vectors and matrices.\n\n\n\n\n\n","category":"module"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.argmaxabs","page":"Arrays","title":"ReachabilityBase.Arrays.argmaxabs","text":"argmaxabs(x::AbstractArray)\n\nReturn the index with the absolute-wise maximum entry.\n\nInput\n\nx – array\n\nOutput\n\nThe index i such that |x[i]| >= |x[j]| for all j.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.cross_product-Union{Tuple{AbstractMatrix{N}}, Tuple{N}} where N<:Real","page":"Arrays","title":"ReachabilityBase.Arrays.cross_product","text":"cross_product(M::AbstractMatrix{N}) where {N<:Real}\n\nCompute the high-dimensional cross product of n-1 n-dimensional vectors.\n\nInput\n\nM – n  n - 1-dimensional matrix\n\nOutput\n\nA vector.\n\nAlgorithm\n\nThe cross product is defined as follows:\n\nleft dots (-1)^n+1 det(M^i) dots right^T\n\nwhere M^i is defined as M with the i-th row removed. See Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.\n\n\n\n\n\n","category":"method"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.distance-Union{Tuple{N}, Tuple{AbstractVector{N}, AbstractVector{N}}} where N","page":"Arrays","title":"ReachabilityBase.Arrays.distance","text":"distance(x::AbstractVector{N}, y::AbstractVector{N}; [p]::Real=N(2)) where {N}\n\nCompute the distance between two vectors with respect to the given p-norm, computed as\n\n    x - y_p = left( sum_i=1^n  x_i - y_i ^p right)^1p\n\nInput\n\nx – vector\ny – vector\np – (optional, default: 2.0) the p-norm used; p = 2.0 corresponds to        the usual Euclidean norm\n\nOutput\n\nA scalar representing  x - y _p.\n\n\n\n\n\n","category":"method"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.dot_zero","page":"Arrays","title":"ReachabilityBase.Arrays.dot_zero","text":"dot_zero(x::AbstractVector{N}, y::AbstractVector{N}) where{N<:Real}\n\nDot product with preference for zero value in the presence of infinity values.\n\nInput\n\nx – first vector\ny – second vector\n\nOutput\n\nThe dot product of x and y, but with the rule that 0 * Inf == 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.extend","page":"Arrays","title":"ReachabilityBase.Arrays.extend","text":"extend(M::AbstractMatrix; check_rank=true)\n\nReturn an invertible extension of M whose first n columns span the column space of M, assuming that size(M) = (m, n), m > n and the rank of M is n.\n\nInput\n\nM          – rectangular m × n matrix with m > n and full rank (i.e. its                 rank is n)\ncheck_rank – (optional, default: true) if true, check the rank assumption,                 otherwise do not perform this check\n\nOutput\n\nThe tuple (Mext, inv_Mext), where Mext is a square m × m invertible matrix that extends M, i.e. in the sense that Mext = [M | Q2], and the rank of Mext is m. Here, inv_Mext is the inverse of Mext.\n\nAlgorithm\n\nFirst we compute the QR decomposition of M to extract a suitable subspace of column vectors (Q2) that are orthogonal to the column span of M. Then we observe that the inverse of the extended matrix Mext = [M | Q2] is [R⁻¹Qᵀ; Q2ᵀ].\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.extend_with_zeros","page":"Arrays","title":"ReachabilityBase.Arrays.extend_with_zeros","text":"extend_with_zeros(x::AbstractVector, indices::AbstractVector{<:Int})\n\nExtend a vector with zeros in the given dimensions.\n\nInput\n\nx       – vector\nindices – indices to extend, from the interval              1:(length(x) + length(indices))\n\nOutput\n\nA new vector.\n\nNotes\n\nThe indices in the extension list are interpreted on the output vector. This is best understood with an example. Let x = [1, 2, 3] and indices = [3, 5]. Then the output vector is y = [1, 2, 0, 3, 0]. Indeed, y[3] == y[5] == 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.hasfullrowrank","page":"Arrays","title":"ReachabilityBase.Arrays.hasfullrowrank","text":"hasfullrowrank(M::AbstractMatrix)\n\nCheck whether a matrix has full row rank.\n\nInput\n\nM – matrix\n\nOutput\n\ntrue iff the matrix has full row rank.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.inner","page":"Arrays","title":"ReachabilityBase.Arrays.inner","text":"inner(x::AbstractVector{N}, A::AbstractMatrix{N}, y::AbstractVector{N}\n     ) where {N}\n\nCompute the inner product xᵀ A y.\n\nInput\n\nx – vector on the left\nA – matrix\ny – vector on the right\n\nOutput\n\nThe (scalar) result of the multiplication.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.is_cyclic_permutation","page":"Arrays","title":"ReachabilityBase.Arrays.is_cyclic_permutation","text":"is_cyclic_permutation(candidate::AbstractVector, paragon::AbstractVector)\n\nChecks if the elements in candidate are a cyclic permutation of the elements in paragon.\n\nInput\n\ncandidate – candidate vector\nparagon   – paragon vector\n\nOutput\n\nA boolean indicating if the elements of candidate are in the same order as in paragon or any of its cyclic permutations.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.is_right_turn","page":"Arrays","title":"ReachabilityBase.Arrays.is_right_turn","text":"is_right_turn([O::AbstractVector{<:Real}=[0, 0]], u::AbstractVector{<:Real},\n              v::AbstractVector{<:Real})\n\nDetermine whether the acute angle defined by three 2D points O, u, v in the plane is a right turn (< 180° counter-clockwise) with respect to the center O. Determine if the acute angle defined by two 2D vectors is a right turn (< 180° counter-clockwise) with respect to the center O.\n\nInput\n\nO – (optional; default: [0, 0]) 2D center point\nu – first 2D direction\nv – second 2D direction\n\nOutput\n\ntrue iff the vectors constitute a right turn.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.isabove","page":"Arrays","title":"ReachabilityBase.Arrays.isabove","text":"isabove(u::AbstractVector, v1::AbstractVector, v2::AbstractVector)\n\nChecks whether the difference v1 - v2 points toward the given direction u.\n\nInput\n\nu  – direction\nv1 – first vector\nv2 – second vector\n\nOutput\n\nA Boolean indicating whether the difference of the given vectors points toward the given direction.\n\nAlgorithm\n\nThe result is equivalent to dot(u, v1 - v2) > 0, but the implementation avoids the allocation of the difference vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.isinvertible","page":"Arrays","title":"ReachabilityBase.Arrays.isinvertible","text":"isinvertible(M::Matrix; [cond_tol]::Number=1.0e6)\n\nA sufficient check of a matrix being invertible (or nonsingular).\n\nInput\n\nM        – matrix\ncond_tol – (optional, default: 1.0e6) tolerance of matrix condition\n\nOutput\n\nIf the result is true, M is invertible. If the result is false, the matrix is non-square or not well-conditioned.\n\nAlgorithm\n\nWe check whether the matrix is square and well-conditioned (via iswellconditioned).\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.ismultiple","page":"Arrays","title":"ReachabilityBase.Arrays.ismultiple","text":"ismultiple(u::AbstractVector{<:Real}, v::AbstractVector{<:Real})\n\nCheck whether two vectors are linearly dependent.\n\nInput\n\nu – first vector\nv – second vector\n\nOutput\n\n(true, k) iff the vectors are identical up to a scaling factor k ≠ 0 such that u = k * v, and (false, 0) otherwise.\n\nExamples\n\njulia> ismultiple([1, 2, 3], [2, 4, 6])\n(true, 0.5)\n\njulia> ismultiple([1, 2, 3], [3, 2, 1])\n(false, 0)\n\njulia> ismultiple([1, 2, 3], [-1, -2, -3])\n(true, -1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.ispermutation","page":"Arrays","title":"ReachabilityBase.Arrays.ispermutation","text":"ispermutation(u::AbstractVector{T}, v::AbstractVector) where {T}\n\nCheck that two vectors contain the same elements up to reordering.\n\nInput\n\nu – first vector\nv – second vector\n\nOutput\n\ntrue iff the vectors are identical up to reordering.\n\nExamples\n\njulia> ispermutation([1, 2, 2], [2, 2, 1])\ntrue\n\njulia> ispermutation([1, 2, 2], [1, 1, 2])\nfalse\n\nNotes\n\nContainment check is performed using Comparison._in(e, v), so in the case of floating point numbers, the precision to which the check is made is determined by the type of elements in v. See _in and _isapprox for more information.\n\nNote that approximate equality is not an equivalence relation. Hence the result may depend on the order of the elements.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.issquare","page":"Arrays","title":"ReachabilityBase.Arrays.issquare","text":"issquare(M::AbstractMatrix)\n\nCheck whether a matrix is square.\n\nInput\n\nM – matrix\n\nOutput\n\ntrue iff the matrix is square.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.iswellconditioned","page":"Arrays","title":"ReachabilityBase.Arrays.iswellconditioned","text":"iswellconditioned(M::Matrix; [cond_tol]::Number=1.0e6)\n\nA check of a matrix being sufficiently well-conditioned.\n\nInput\n\nM        – matrix\ncond_tol – (optional, default: 1.0e6) tolerance of matrix condition\n\nOutput\n\ntrue iff M is well-conditioned subject to the cond_tol parameter.\n\nAlgorithm\n\nWe check whether the matrix condition number cond(M) is below the prescribed tolerance cond_tol.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.matrix_type","page":"Arrays","title":"ReachabilityBase.Arrays.matrix_type","text":"matrix_type(T)\n\nReturn a corresponding matrix type with respect to type T.\n\nInput\n\nT – vector or matrix type\n\nOutput\n\nA matrix type that corresponds in some sense (see Notes below) to T.\n\nNotes\n\nIf T is a sparse vector or a sparse matrix, the corresponding type is also a sparse matrix.\nIf T is a regular vector (i.e. Vector) or a regular matrix (i.e. Matrix), the corresponding type is also a regular matrix.\nOtherwise, the corresponding type is a regular matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.nonzero_columns","page":"Arrays","title":"ReachabilityBase.Arrays.nonzero_columns","text":"nonzero_columns(A::AbstractMatrix; [comparison]=isapproxzero)\n\nReturn all columns that have at least one non-zero entry.\n\nInput\n\nA          – matrix\ncomparison – (optional; default: isapproxzero) function to check for                 equality with zero\n\nOutput\n\nA vector of indices.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.nonzero_indices","page":"Arrays","title":"ReachabilityBase.Arrays.nonzero_indices","text":"nonzero_indices(v::AbstractVector{N}) where {N<:Real}\n\nReturn the indices in which a vector is non-zero.\n\nInput\n\nv – vector\n\nOutput\n\nA vector of ascending indices i such that the vector is non-zero in dimension i.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.projection_matrix","page":"Arrays","title":"ReachabilityBase.Arrays.projection_matrix","text":"projection_matrix(block::AbstractVector{Int}, n::Int, [N]::Type{<:Number}=Float64)\n\nReturn the projection matrix associated to the given block of variables.\n\nInput\n\nblock – integer vector with the variables of interest\nn     – integer representing the ambient dimension\nN     – (optional, default: Float64) number type\n\nOutput\n\nA sparse matrix that corresponds to the projection onto the variables in block.\n\nExamples\n\njulia> proj = projection_matrix([1, 3], 4)\n2×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅\n\njulia> Matrix(proj)\n2×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.rand_pos_neg_zerosum_vector","page":"Arrays","title":"ReachabilityBase.Arrays.rand_pos_neg_zerosum_vector","text":"rand_pos_neg_zerosum_vector(n::Int; [N]::Type{<:Real}=Float64,\n                                    [rng]::AbstractRNG=GLOBAL_RNG)\n\nCreate a vector of random numbers such that the total sum is (approximately) zero, no duplicates exist, all positive entries come first, and all negative entries come last.\n\nInput\n\nn   – length of the vector\nN   – (optional; default: Float64) numeric type\nrng – (optional; default: GLOBAL_RNG) random number generator\n\nOutput\n\nA vector as described above.\n\nAlgorithm\n\nThis is the first phase of the algorithm described here.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#Base.rationalize","page":"Arrays","title":"Base.rationalize","text":"rationalize(::Type{T}, x::AbstractArray{N}, tol::Real) where {T<:Integer, N<:AbstractFloat}\n\nApproximate an array of floating point numbers as a rational vector with entries of the given integer type.\n\nInput\n\nT   – (optional, default: Int) integer type to represent the rationals\nx   – vector of floating point numbers\ntol – (optional, default: eps(N)) tolerance the result at entry i          will differ from x[i] by no more than tol\n\nOutput\n\nAn array of type Rational{T} where the i-th entry is the rationalization of the i-th component of x.\n\nNotes\n\nSee also Base.rationalize.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.rectify","page":"Arrays","title":"ReachabilityBase.Arrays.rectify","text":"rectify(x::AbstractArray{N}) where {N<:Real}\n\nRectify an array, i.e., take the element-wise maximum with zero.\n\nInput\n\nx – array\n\nOutput\n\nA copy of the array where each negative entry is replaced by zero.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.remove_duplicates_sorted!","page":"Arrays","title":"ReachabilityBase.Arrays.remove_duplicates_sorted!","text":"remove_duplicates_sorted!(v::AbstractVector)\n\nRemove duplicate entries in a sorted vector.\n\nInput\n\nv – sorted vector\n\nOutput\n\nThe input vector without duplicates.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.remove_zero_columns","page":"Arrays","title":"ReachabilityBase.Arrays.remove_zero_columns","text":"remove_zero_columns(A::AbstractMatrix)\n\nReturn a matrix with all columns containing only zero entries removed.\n\nInput\n\nA – matrix\n\nOutput\n\nThe original matrix A if it contains no zero columns or otherwise a new matrix where those columns have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.right_turn","page":"Arrays","title":"ReachabilityBase.Arrays.right_turn","text":"right_turn([O::AbstractVector{<:Real}=[0, 0]], u::AbstractVector{<:Real},\n           v::AbstractVector{<:Real})\n\nCompute a scalar that determines whether the acute angle defined by three 2D points O, u, v in the plane is a right turn (< 180° counter-clockwise) with respect to the center O.\n\nInput\n\nO – (optional; default: [0, 0]) 2D center point\nu – first 2D point\nv – second 2D point\n\nOutput\n\nA scalar representing the rotation. If the result is 0, the points are collinear; if it is positive, the points constitute a positive angle of rotation around O from u to v; otherwise they constitute a negative angle.\n\nAlgorithm\n\nThe cross product is used to determine the sense of rotation.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.same_sign","page":"Arrays","title":"ReachabilityBase.Arrays.same_sign","text":"same_sign(A::AbstractArray{N}; [optimistic]::Bool=false) where {N}\n\nCheck whether all elements of the given array have the same sign.\n\nInput\n\nA          – array\noptimistic – (optional; default: false) flag for expressing that the                 expected result is true\n\nOutput\n\ntrue if and only if all elements in M have the same sign.\n\nAlgorithm\n\nIf optimistic is false, we check the sign of the first element and compare to the sign of all elements.\n\nIf optimistic is true, we compare the absolute element sum with the sum of the absolute of the elements; this is faster if the result is true because there is no branching.\n\n    sum_i A_i = sum_i A_i\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.samedir","page":"Arrays","title":"ReachabilityBase.Arrays.samedir","text":"samedir(u::AbstractVector{<:Real}, v::AbstractVector{<:Real})\n\nCheck whether two vectors point in the same direction.\n\nInput\n\nu – first vector\nv – second vector\n\nOutput\n\n(true, k) iff the vectors are identical up to a positive scaling factor k such that u = k * v, and (false, 0) otherwise.\n\nExamples\n\njulia> samedir([1, 2, 3], [2, 4, 6])\n(true, 0.5)\n\njulia> samedir([1, 2, 3], [3, 2, 1])\n(false, 0)\n\njulia> samedir([1, 2, 3], [-1, -2, -3])\n(false, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.SingleEntryVector","page":"Arrays","title":"ReachabilityBase.Arrays.SingleEntryVector","text":"SingleEntryVector{N} <: AbstractVector{N}\n\nA sparse unit vector with arbitrary one-element.\n\nFields\n\ni – index of non-zero entry\nn – vector length\nv – non-zero entry\n\n\n\n\n\n","category":"type"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.substitute","page":"Arrays","title":"ReachabilityBase.Arrays.substitute","text":"substitute(substitution::Dict{Int, T}, x::AbstractVector{T}) where {T}\n\nApply a substitution to a given vector.\n\nInput\n\nsubstitution – substitution (a mapping from an index to a new value)\nx            – vector\n\nOutput\n\nA fresh vector corresponding to x after substitution was applied.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.substitute!","page":"Arrays","title":"ReachabilityBase.Arrays.substitute!","text":"substitute!(substitution::Dict{Int, T}, x::AbstractVector{T}) where {T}\n\nApply a substitution to a given vector.\n\nInput\n\nsubstitution – substitution (a mapping from an index to a new value)\nx            – vector (modified in this function)\n\nOutput\n\nThe same (but see the Notes below) vector x but after substitution was applied.\n\nNotes\n\nThe vector x is modified in-place if it has type Vector or SparseVector. Otherwise, we first create a new Vector from it.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.to_matrix","page":"Arrays","title":"ReachabilityBase.Arrays.to_matrix","text":"to_matrix(vectors::AbstractVector{VN},\n          [m]=length(vectors[1]),\n          [MT]=matrix_type(VN)) where {VN}\n\nInput\n\nvectors – list of vectors\nm       – (optional; default: length(vectors[1])) number of rows\nMT      – (optional; default: matrix_type(VN)) type of target matrix\n\nOutput\n\nA matrix with the column vectors from vectors in the same order.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.to_negative_vector","page":"Arrays","title":"ReachabilityBase.Arrays.to_negative_vector","text":"to_negative_vector(v::AbstractVector{N}) where {N}\n\nNegate a vector and convert to type Vector.\n\nInput\n\nv – vector\n\nOutput\n\nA Vector equivalent to -v.\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.uniform_partition","page":"Arrays","title":"ReachabilityBase.Arrays.uniform_partition","text":" uniform_partition(n::Int, block_size::Int)\n\nCompute a uniform block partition of the given size.\n\nInput\n\nn          – number of dimensions of the partition\nblock_size – size of each block\n\nOutput\n\nA vector of ranges, Vector{UnitRange{Int}}, such that the size of each block is the same, if possible.\n\nExamples\n\nIf the number of dimensions n is 2, we have two options: either two blocks of size 1 or one block of size 2:\n\njulia> uniform_partition(2, 1)\n2-element Vector{UnitRange{Int64}}:\n 1:1\n 2:2\n\njulia> uniform_partition(2, 2)\n1-element Vector{UnitRange{Int64}}:\n 1:2\n\nIf the block_size argument is not compatible with (i.e., does not divide) n, the output is filled with one block of the size needed to reach n:\n\njulia> uniform_partition(3, 1)\n3-element Vector{UnitRange{Int64}}:\n 1:1\n 2:2\n 3:3\n\njulia> uniform_partition(3, 2)\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:3\n\njulia> uniform_partition(10, 6)\n2-element Vector{UnitRange{Int64}}:\n 1:6\n 7:10\n\n\n\n\n\n","category":"function"},{"location":"lib/Arrays/#ReachabilityBase.Arrays.vector_type","page":"Arrays","title":"ReachabilityBase.Arrays.vector_type","text":"vector_type(T)\n\nReturn a corresponding vector type with respect to type T.\n\nInput\n\nT – vector or matrix type\n\nOutput\n\nA vector type that corresponds in some sense (see Notes below) to T.\n\nNotes\n\nIf T is a sparse vector or a sparse matrix, the corresponding type is also a sparse vector.\nIf T is a regular vector (i.e. Vector) or a regular matrix (i.e. Matrix), the corresponding type is also a regular vector.\nOtherwise, the corresponding type is a regular vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/Basetype/#Basetype","page":"Basetype","title":"Basetype","text":"","category":"section"},{"location":"lib/Basetype/","page":"Basetype","title":"Basetype","text":"This section of the manual describes the Basetype module.","category":"page"},{"location":"lib/Basetype/","page":"Basetype","title":"Basetype","text":"Pages = [\"Basetype.md\"]\nDepth = 3","category":"page"},{"location":"lib/Basetype/","page":"Basetype","title":"Basetype","text":"CurrentModule = ReachabilityBase.Basetype","category":"page"},{"location":"lib/Basetype/","page":"Basetype","title":"Basetype","text":"Basetype\nbasetype","category":"page"},{"location":"lib/Basetype/#ReachabilityBase.Basetype","page":"Basetype","title":"ReachabilityBase.Basetype","text":"Basetype\n\nThis module provides the functionality to obtain the base type of a type or object.\n\n\n\n\n\n","category":"module"},{"location":"lib/Basetype/#ReachabilityBase.Basetype.basetype","page":"Basetype","title":"ReachabilityBase.Basetype.basetype","text":"basetype(T::Type)\n\nReturn the base type of the given type (i.e., without type parameters).\n\nInput\n\nT – type\n\nOutput\n\nThe base type of T.\n\njulia> using ReachabilityBase.Basetype\n\njulia> basetype(Float64)\nFloat64\n\njulia> basetype(Rational{Int})\nRational\n\n\n\n\n\nbasetype(x)\n\nReturn the base type of the given object (i.e., without type parameters).\n\nInput\n\nx – object\n\nOutput\n\nThe base type of x.\n\nExamples\n\njulia> using ReachabilityBase.Basetype\n\njulia> basetype(1.0)\nFloat64\n\njulia> basetype(1//1)\nRational\n\n\n\n\n\n","category":"function"},{"location":"lib/Iteration/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"lib/Iteration/","page":"Iteration","title":"Iteration","text":"This section of the manual describes the Iteration module.","category":"page"},{"location":"lib/Iteration/","page":"Iteration","title":"Iteration","text":"Pages = [\"Iteration.md\"]\nDepth = 3","category":"page"},{"location":"lib/Iteration/","page":"Iteration","title":"Iteration","text":"CurrentModule = ReachabilityBase.Iteration","category":"page"},{"location":"lib/Iteration/","page":"Iteration","title":"Iteration","text":"Iteration\nStrictlyIncreasingIndices\nNondecreasingIndices","category":"page"},{"location":"lib/Iteration/#ReachabilityBase.Iteration","page":"Iteration","title":"ReachabilityBase.Iteration","text":"Iteration\n\nThis module provides convenience functionality for iteration.\n\n\n\n\n\n","category":"module"},{"location":"lib/Iteration/#ReachabilityBase.Iteration.StrictlyIncreasingIndices","page":"Iteration","title":"ReachabilityBase.Iteration.StrictlyIncreasingIndices","text":"StrictlyIncreasingIndices\n\nIterator over the vectors of m strictly increasing indices from 1 to n.\n\nFields\n\nn – size of the index domain\nm – number of indices to choose (resp. length of the vectors)\n\nNotes\n\nThe vectors are modified in-place.\n\nThe iterator ranges over binomnm (n choose m) possible vectors.\n\nThis implementation results in a lexicographic order with the last index growing first.\n\nSee also NondecreasingIndices for a nondecreasing iterator.\n\nExamples\n\njulia> for v in StrictlyIncreasingIndices(4, 2)\n           println(v)\n       end\n[1, 2]\n[1, 3]\n[1, 4]\n[2, 3]\n[2, 4]\n[3, 4]\n\n\n\n\n\n","category":"type"},{"location":"lib/Iteration/#ReachabilityBase.Iteration.NondecreasingIndices","page":"Iteration","title":"ReachabilityBase.Iteration.NondecreasingIndices","text":"NondecreasingIndices\n\nIterator over the vectors of m nondecreasing indices from 1 to n.\n\nFields\n\nn – size of the index domain\nm – number of indices to choose (resp. length of the vectors)\n\nNotes\n\nThe vectors are modified in-place.\n\nThe iterator ranges over binomn + m - 1m (n + m - 1 choose m) possible vectors.\n\nThis implementation results in a lexicographic order with the last index growing first.\n\nSee also StrictlyIncreasingIndices for a strictly increasing iterator.\n\nExamples\n\njulia> for v in NondecreasingIndices(4, 2)\n           println(v)\n       end\n[1, 1]\n[1, 2]\n[1, 3]\n[1, 4]\n[2, 2]\n[2, 3]\n[2, 4]\n[3, 3]\n[3, 4]\n[4, 4]\n\n\n\n\n\n","category":"type"},{"location":"lib/Require/#Require","page":"Require","title":"Require","text":"","category":"section"},{"location":"lib/Require/","page":"Require","title":"Require","text":"This section of the manual describes the Require module.","category":"page"},{"location":"lib/Require/","page":"Require","title":"Require","text":"Pages = [\"Require.md\"]\nDepth = 3","category":"page"},{"location":"lib/Require/","page":"Require","title":"Require","text":"CurrentModule = ReachabilityBase.Require","category":"page"},{"location":"lib/Require/","page":"Require","title":"Require","text":"Require\nrequire\n@required","category":"page"},{"location":"lib/Require/#ReachabilityBase.Require","page":"Require","title":"ReachabilityBase.Require","text":"Require\n\nThis module provides convenience functionality to be used in combination with the Requires.jl package.\n\n\n\n\n\n","category":"module"},{"location":"lib/Require/#ReachabilityBase.Require.require","page":"Require","title":"ReachabilityBase.Require.require","text":"require(mod, packages; [fun_name]::String=\"\", [explanation]::String=\"\")\n\nCheck for one or more optional packages and print an error message if any of them is not loaded.\n\nInput\n\nmod         – module where the package should be loaded; use @__MODULE__\npackages    – symbol or list of symbols (the package name(s))\nfun_name    – (optional; default: \"\") name of the function that requires                  the package\nexplanation – (optional; default: \"\") additional explanation in the error                  message\nrequire_all – (optional; default: true) flag to require all packages\n\nOutput\n\nIf all packages are loaded, this function has no effect. Otherwise, it prints an error message.\n\nNotes\n\nThe argument mod should typically be @__MODULE__, but since this is a macro, it has to be inserted by the caller.\n\nThe argument require_all can be set to false to require only one of the given packages. This is useful if multiple packages provide a functionality and any of them is fine.\n\nThis function uses @assert and hence loses its ability to print an error message if assertions are deactivated (see the Assertions module).\n\nSee also the @required macro for a more concise syntax.\n\n\n\n\n\n","category":"function"},{"location":"lib/Require/#ReachabilityBase.Require.@required","page":"Require","title":"ReachabilityBase.Require.@required","text":"@required(package)\n\nCheck for an optional package and print an error message if any of them is not loaded.\n\nInput\n\npackage – package name\n\nOutput\n\nIf the package is loaded, this macro has no effect. Otherwise, it prints an error message.\n\nThis macro uses @assert and hence loses its ability to print an error message if assertions are deactivated (see the Assertions module).\n\nSee also the require function for a more customizable version.\n\n\n\n\n\n","category":"macro"},{"location":"lib/Subtypes/#Subtypes","page":"Subtypes","title":"Subtypes","text":"","category":"section"},{"location":"lib/Subtypes/","page":"Subtypes","title":"Subtypes","text":"This section of the manual describes the Subtypes module.","category":"page"},{"location":"lib/Subtypes/","page":"Subtypes","title":"Subtypes","text":"Pages = [\"Subtypes.md\"]\nDepth = 3","category":"page"},{"location":"lib/Subtypes/","page":"Subtypes","title":"Subtypes","text":"CurrentModule = ReachabilityBase.Subtypes","category":"page"},{"location":"lib/Subtypes/","page":"Subtypes","title":"Subtypes","text":"Subtypes\nsubtypes","category":"page"},{"location":"lib/Subtypes/#ReachabilityBase.Subtypes","page":"Subtypes","title":"ReachabilityBase.Subtypes","text":"Subtypes\n\nThis module provides the functionality to obtain the subtypes in a type hierarchy.\n\n\n\n\n\n","category":"module"},{"location":"lib/Subtypes/#InteractiveUtils.subtypes","page":"Subtypes","title":"InteractiveUtils.subtypes","text":"subtypes(atype, concrete::Bool)\n\nReturn the subtypes of a given abstract type.\n\nInput\n\natype    – an abstract type\nconcrete – if true, only return the concrete subtypes (leaves of the type               hierarchy); otherwise return only the direct subtypes\n\nOutput\n\nA list with the subtypes of the abstract type atype, sorted alphabetically.\n\nExamples\n\nConsider the Integer type. If we pass concrete = false, the implementation imitates Base.subtypes without any arguments.\n\njulia> using ReachabilityBase.Subtypes\n\njulia> subtypes(Integer, false)\n3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n\nIf we pass concrete = true, we obtain the concrete subtypes instead.\n\njulia> subtypes(Integer, true)\n12-element Vector{Type}:\n BigInt\n Bool\n Int128\n Int16\n Int32\n Int64\n Int8\n UInt128\n UInt16\n UInt32\n UInt64\n UInt8\n\n\n\n\n\n","category":"function"},{"location":"#ReachabilityBase.jl","page":"Home","title":"ReachabilityBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ReachabilityBase","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReachabilityBase.jl is a basic Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"}]
}
